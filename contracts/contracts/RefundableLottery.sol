// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol";

interface IChipsToken is IERC20 {
    function mint(address to, uint256 amount) external;
    function directTransferFrom(address from, address to, uint256 amount) external;
}

// RefundableLottery contract rules:
// 0.This contract is a lottery contract that allows the players to buy tickets with ether or ChipsToken.
// 1.Players can specify a lucky number between [0, 65535] as their ticket number when buying a ticket. 
// 2.The jackpot number is generated by Chainlink and winner(s) get(s) all the prize pool in the current round. 
// 3.If there is no winner in the current round, then all players in THIS round can withdraw 99% of their costs.
// 4.The contract manager take the management fee (1% of the deposit balance, ether or chips).
// 5.When refunding ether, the player will get equivalent ChipsToken as the management fee they spend.
// 6.When players purchase tickets using ChipsToken, they will receive a 50% discount compared to paying with Ether.
// 7.The number of players using ChipsToken should be less than 50% of the total players in a round.
// NOTE: If there's a winner in a round, winner(s) will get all the prize pool so other players can't refund their tickets any more. 

contract RefundableLottery is VRFConsumerBaseV2Plus {
  // 1% management fee
  uint public constant MANAGEMENT_FEE_RATE = 1;

  // ether for each ticket
  uint public constant TICKET_PRICE_IN_ETHER = 0.01 ether;

  // Ticket number range [0, 65535]
  uint public constant TICKET_NUMBER_RANGE = 65535;

  // 1000 chips == 1 eth
  uint public constant CHIPS_PRICE_PER_ETHER = 1000;

  // 50% discount for players using ChipsToken
  uint public constant DISCOUNT_RATE = 50;

  // The price of ChipsToken is 1 ether == 1000 chips, so the original price of a ticket in ChipsToken is 10 chips.
  // But we offer a 50% discount for players using ChipsToken, so the price of a ticket in ChipsToken is 5 chips.
  uint public constant TICKET_PRICE_IN_CHIPS = TICKET_PRICE_IN_ETHER * CHIPS_PRICE_PER_ETHER;
  
  // In a round, the number of players using ChipsToken should be less than 50% of the total players. 
  uint public constant MAX_PARTICIPATE_RATE_USING_CHIPS = 50;

  // The period of each round by blocks, about 1.5 hours.
  uint public constant ROUND_PERIOD = 1000;

  uint public constant REWARD_CHIPS_FOR_OPERATOR = 1 ether;
  // The manager of the contract takes the 1% management fee
  address payable public immutable manager;
  
  //The current round number
  uint public roundNumber;

  enum RoundState { UPCOMMING, PLAYING, READYTOROLL, ROLLING, READYTODRAW, ENDED}

  struct RoundInfo{
      RoundState state;
      uint startBlockNumber;
      uint chainlinkResult;
      uint jackpotNumber;
      uint requestId;
      uint winnerCount;
  }
  mapping (uint => RoundInfo) public roundInfos;

  //The mapping of the purchase count in each round
  mapping(uint => uint) public etherPurchaseCount;
  mapping(uint => uint) public chipsPurchaseCount;

  //The mapping of the purchase count of each player in each round
  mapping(uint => mapping(address => uint) ) public holderEtherPurchaseCount;
  mapping(uint => mapping(address => uint) ) public holderChipsPurchaseCount;

  //The holders of a ticket.
  //A ticket can be held by more than one player.
  //If the ticket number is chosen as the jackpot number, all the holders of this ticket will share the prize.
  mapping(uint => mapping(uint => address[])) public ticketHolders;

  //The balance of each round.
  //If there is no winner in this round, all players can refund 99% of their ether in this round,
  //and the round balance will be reduced every time a player makes a refund.
  //If there is a winner in this round, the winner(s) get(s) all the ether in this round, 
  //and round_balance will be set to ZERO after draw.
  mapping(uint => uint) public roundEtherBalance;
  mapping(uint => uint) public roundChipsBalance;

  //The mapping of requestId to round number
  mapping(uint => uint) public requestIdToRound;

  //The chips token contract, which is used to mint ChipsToken for the players when refunding.
  IChipsToken public chipsToken;

  event RoundStarted(uint indexed roundNumber);
  event BuyTicket(uint indexed roundNumber, address indexed player, uint ticketNumber, uint amount, bool inChips);
  event LotteryRolling(uint indexed roundNumber, uint requestId, address roller);
  event LotteryDrawing(uint indexed roundNumber, uint requestId, uint chainlinkResult, uint jackpotNumber);
  event DrawLottery(uint indexed roundNumber, uint jackpotNumber, address winner, uint amount, bool inChips);
  event RoundEnded(uint indexed roundNumber, uint jackpotNumber, uint winnerCount);
  event Refund( uint indexed roundNumber, address indexed player, uint refundAmount, bool inChips);

  // The gas lane to use, which specifies the maximum gas price to bump to.
  // For a list of available gas lanes on each network,
  // see https://docs.chain.link/vrf/v2-5/supported-networks
  bytes32 public keyHash;
  
  uint32 public callbackGasLimit = 100000;

  uint16 public requestConfirmations = 3;

  uint256 public subscriptionId;

  constructor(uint256 _subscriptionId, address _vrf, bytes32 _keyHash, address _chipsToken) 
    VRFConsumerBaseV2Plus(_vrf) 
  {
    keyHash = _keyHash;
    subscriptionId = _subscriptionId;

    chipsToken = IChipsToken(_chipsToken);
    manager = payable(msg.sender);

    roundNumber = 1;
    roundInfos[roundNumber].state = RoundState.PLAYING;
    roundInfos[roundNumber].startBlockNumber = block.number;
    emit RoundStarted(roundNumber);
  }

  //Pickup a lucky number between [0, 65535] as your ticket number, 0 and 65535 are both acceptable.
  function buyTicketWithEther(uint _ticketNumber) public payable {
    require(roundInfos[roundNumber].state == RoundState.PLAYING, "The current round is not playing");
    require(roundInfos[roundNumber].startBlockNumber + ROUND_PERIOD > block.number, "The current round is end, please wait for the next round");
    require(msg.value == TICKET_PRICE_IN_ETHER, "The price for a ticket is 0.01 ether");
    require(_ticketNumber >= 0 && _ticketNumber <= TICKET_NUMBER_RANGE, "The ticket number should be between [0,65535]");
    require(msg.sender == tx.origin, "Only EOA(Externally Owned Account) can call this function");

    holderEtherPurchaseCount[roundNumber][msg.sender] += 1;
    ticketHolders[roundNumber][_ticketNumber].push(msg.sender);
    roundEtherBalance[roundNumber] += msg.value;
    
    etherPurchaseCount[roundNumber] += 1;
    emit BuyTicket( roundNumber, msg.sender, _ticketNumber, msg.value, false);
  }

  function buyTicketWithChips(uint _ticketNumber) public {
    require(roundInfos[roundNumber].state == RoundState.PLAYING, "The current round is not playing");
    require(roundInfos[roundNumber].startBlockNumber + ROUND_PERIOD > block.number, "The current round is end, please wait for the next round");     
    require(_ticketNumber >= 0 && _ticketNumber <= TICKET_NUMBER_RANGE, "The ticket number should be between [0,65535]");
    require(msg.sender == tx.origin, "Only EOA(Externally Owned Account) can call this function");

    chipsPurchaseCount[roundNumber] += 1;
    uint a = chipsPurchaseCount[roundNumber];
    uint b = etherPurchaseCount[roundNumber];
    require(b > 0, "There is no player using Ether in this round, so you can not use ChipsToken");
    require((a*100)/(a+b) <= MAX_PARTICIPATE_RATE_USING_CHIPS, "The number of players using ChipsToken should be less than 50% of the total players");
    
    holderChipsPurchaseCount[roundNumber][msg.sender] += 1;
    ticketHolders[roundNumber][_ticketNumber].push(msg.sender);

    //The directTransferFrom will revert if the player does not have enough ChipsToken.
    uint discountedPriceInChips = getDiscountedPriceInChips();
    chipsToken.directTransferFrom(msg.sender, address(this), discountedPriceInChips);
    roundChipsBalance[roundNumber] += discountedPriceInChips;

    emit BuyTicket(roundNumber, msg.sender, _ticketNumber, discountedPriceInChips, true);
  }
      
  //Any player can call this function to trigger the draw operation.
  //This function will request a random number from Chainlink VRF.
  //And the Chainlink VRF will callback the fulfillRandomWords function in several block.
  function rollTheDice() public returns(uint){
    require(getCurRoundState() == RoundState.READYTOROLL, "The current round is not ready to roll");
    
    //The rolling operation can only be called one time for each round.
    roundInfos[roundNumber].state = RoundState.ROLLING;

    uint requestId = s_vrfCoordinator.requestRandomWords(
      VRFV2PlusClient.RandomWordsRequest({
        keyHash: keyHash,
        subId: subscriptionId,
        requestConfirmations: requestConfirmations,
        callbackGasLimit: callbackGasLimit,
        numWords: 1,
        extraArgs: VRFV2PlusClient._argsToBytes(
            VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
        )
      })
    );
    roundInfos[roundNumber].requestId = requestId;
    requestIdToRound[requestId] = roundNumber;
    emit LotteryRolling(roundNumber, requestId, msg.sender);

    //The operator of rolling the lottery will get ChipsToken as reward.
    chipsToken.mint(msg.sender, REWARD_CHIPS_FOR_OPERATOR);
    return requestId;
  }

  //The Chainlink VRF will callback this function to fulfill the random number request.
  function fulfillRandomWords(uint256 _requestId, uint256[] calldata _randomWords) internal override {
    require(requestIdToRound[_requestId] == roundNumber, "The requestId is not for the current round");
    require(roundInfos[roundNumber].state == RoundState.ROLLING, "The current round state is not ROLLING");
    
    roundInfos[roundNumber].state = RoundState.READYTODRAW;
    roundInfos[roundNumber].chainlinkResult = _randomWords[0];
    //Generate a random number between [0, 65535] using the random number generated by Chainlink VRF.
    roundInfos[roundNumber].jackpotNumber = _randomWords[0] % (TICKET_NUMBER_RANGE + 1); //0 <= jackpotNum <= 65535
    
    emit LotteryDrawing(roundNumber, _requestId, _randomWords[0], roundInfos[roundNumber].jackpotNumber);
  }

  function drawLottery()public{
    require(roundInfos[roundNumber].state == RoundState.READYTODRAW, "The current round state is not READYTODRAW");    
    
    drawLotteryInternal(roundInfos[roundNumber].jackpotNumber);    
    
    //The operator of drawing the lottery will get ChipsToken as reward.
    chipsToken.mint(msg.sender, REWARD_CHIPS_FOR_OPERATOR);
  }

  function drawLotteryInternal(uint _jackpotNum) internal {
    //If there is no player in this round, nothing to do and start the next round.
    if(roundEtherBalance[roundNumber] == 0){
        return;
    }

    //The manager of the contract take the management fee (1% of the deposit balance).
    uint managementFeeEther = roundEtherBalance[roundNumber] * MANAGEMENT_FEE_RATE / 100;
    roundEtherBalance[roundNumber] -= managementFeeEther;
    manager.transfer(managementFeeEther);

    uint managementFeeChips = roundChipsBalance[roundNumber] * MANAGEMENT_FEE_RATE / 100;
    roundChipsBalance[roundNumber] -= managementFeeChips;
    chipsToken.transfer(manager, managementFeeChips);

    //The winners could be more than ONE player and they will share the ether/chips in the current round.
    uint winnerCount = ticketHolders[roundNumber][_jackpotNum].length;
    if(winnerCount > 0){
      uint winnerEther = roundEtherBalance[roundNumber] / winnerCount;
      uint winnerChips = roundChipsBalance[roundNumber] / winnerCount;
      
      roundEtherBalance[roundNumber] = 0;
      roundChipsBalance[roundNumber] = 0;

      for(uint i = 0; i < ticketHolders[roundNumber][_jackpotNum].length; i++){
        payable(ticketHolders[roundNumber][_jackpotNum][i]).transfer(winnerEther);
        emit DrawLottery(roundNumber, _jackpotNum, ticketHolders[roundNumber][_jackpotNum][i], winnerEther, false);
        
        if(winnerChips > 0){
            require(chipsToken.transfer(ticketHolders[roundNumber][_jackpotNum][i], winnerChips), "The transfer of ChipsToken failed");
            emit DrawLottery(roundNumber, _jackpotNum, ticketHolders[roundNumber][_jackpotNum][i], winnerChips, true);
        }
      }
    }

    roundInfos[roundNumber].winnerCount = winnerCount;
    roundInfos[roundNumber].state = RoundState.ENDED;
    emit RoundEnded(roundNumber, _jackpotNum, winnerCount);

    //The next round will not start until the current round is drawn.
    roundNumber += 1;
    roundInfos[roundNumber].state = RoundState.PLAYING;
    roundInfos[roundNumber].startBlockNumber = block.number;
    emit RoundStarted(roundNumber);
  }

  function refundEther(uint _previousRoundNumber) public  {
    require(roundInfos[_previousRoundNumber].state == RoundState.ENDED, "You can not refund a round which is not completed");
    require(roundInfos[_previousRoundNumber].winnerCount == 0, "The prize pool of this round has been taken by the winner(s)");
    
    //A player can refund all the tickets he/she holds in the previous round as long as there is no winner in that round.
    uint ticketsCount = holderEtherPurchaseCount[_previousRoundNumber][msg.sender];
    if(ticketsCount == 0){
      return;
    }
    delete holderEtherPurchaseCount[_previousRoundNumber][msg.sender];

    uint refundAmount = ticketsCount * TICKET_PRICE_IN_ETHER * (100 - MANAGEMENT_FEE_RATE) / 100;
    require(roundEtherBalance[_previousRoundNumber] >= refundAmount, "The balance of this round is not enough for refund");
    require(address(this).balance >= refundAmount, "The contract balance is not enough for refund");
    roundEtherBalance[_previousRoundNumber] -= refundAmount;
    payable(msg.sender).transfer(refundAmount);
    
    emit Refund(_previousRoundNumber, msg.sender, refundAmount, false);

    //As player paid 1% management fee when playing the game, the player will get equivalent ChipsToken when refunding.
    //For example, if a player paid 0.01 ether for a ticket, the management fee is 0.01 * 1% = 0.0001 ether.
    //As the price of chips token is 1 ether == 1000 chips, the player will get 0.0001 * 1000 = 0.1 chips when refunding.
    chipsToken.mint(msg.sender, ticketsCount * TICKET_PRICE_IN_ETHER * MANAGEMENT_FEE_RATE * CHIPS_PRICE_PER_ETHER/100 );
  }

  function refundChips(uint _previousRoundNumber) public {
    require(roundInfos[_previousRoundNumber].state == RoundState.ENDED, "You can not refund a round which is not completed");
    require(roundInfos[_previousRoundNumber].winnerCount == 0, "The prize pool of this round has been taken by the winner(s)");
    
    //A player can refund all the tickets he/she holds in the previous round as long as there is no winner in that round.
    uint ticketsCount = holderChipsPurchaseCount[_previousRoundNumber][msg.sender];
    if(ticketsCount == 0){
        return;
    }
    delete holderChipsPurchaseCount[_previousRoundNumber][msg.sender];

    uint discountedPriceInChips = getDiscountedPriceInChips();
    uint refundAmount = ticketsCount * discountedPriceInChips * (100 - MANAGEMENT_FEE_RATE) / 100;
    require(roundChipsBalance[_previousRoundNumber] >= refundAmount, "The balance of this round is not enough for refund");
    require(chipsToken.balanceOf(address(this)) >= refundAmount, "The contract balance is not enough for refund");
    roundChipsBalance[_previousRoundNumber] -= refundAmount;
    require(chipsToken.transfer(msg.sender, refundAmount), "The transfer of ChipsToken failed");
    
    emit Refund(_previousRoundNumber, msg.sender, refundAmount, true);
    //The player will NOT get extra ChipsToken when refunding chips token.
  }

  function refund(uint _previousRoundNumber) public{
    refundEther(_previousRoundNumber);
    refundChips(_previousRoundNumber);
  }

  function getCurRoundState()public view returns(RoundState){
    RoundState state = roundInfos[roundNumber].state;
    if(state == RoundState.PLAYING && block.number > roundInfos[roundNumber].startBlockNumber + ROUND_PERIOD){
        return RoundState.READYTOROLL;
    }
    return state;
  }

  function getDiscountedPriceInChips()public pure returns(uint){
    return TICKET_PRICE_IN_CHIPS * (100 - DISCOUNT_RATE) / 100;
  }

  function getGlobalConfig() public view returns(uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint){
    return (
      MANAGEMENT_FEE_RATE, 
      TICKET_PRICE_IN_ETHER, 
      TICKET_NUMBER_RANGE, 
      CHIPS_PRICE_PER_ETHER, 
      DISCOUNT_RATE, 
      TICKET_PRICE_IN_CHIPS,
      MAX_PARTICIPATE_RATE_USING_CHIPS, 
      ROUND_PERIOD, 
      REWARD_CHIPS_FOR_OPERATOR,
      roundNumber,
      getDiscountedPriceInChips()
    );
  }

  function getRoundDetail(uint _roundNumber) public view returns(RoundInfo memory, uint, uint, uint, uint, uint, uint){
    if(_roundNumber == 0){
      _roundNumber = roundNumber;
    }

    return (
      roundInfos[_roundNumber],
      etherPurchaseCount[_roundNumber],
      chipsPurchaseCount[_roundNumber],
      holderEtherPurchaseCount[_roundNumber][msg.sender],
      holderChipsPurchaseCount[_roundNumber][msg.sender],
      roundEtherBalance[_roundNumber],
      roundChipsBalance[_roundNumber]
    );
  }
}