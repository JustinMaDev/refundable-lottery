// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol";

interface IChipsToken is IERC20 {
    function mint(address to, uint256 amount) external;
    function directTransferFrom(address from, address to, uint256 amount) external;
}

// RefundableLottery contract rules:
// 0.This contract is a lottery contract that allows the players to buy tickets with ether or ChipsToken.
// 1.Players can specify a lucky number between [0, 65535] as their ticket number when buying a ticket. 
// 2.The jackpot number is generated by Chainlink and winner(s) get(s) all the prize pool in the current round. 
// 3.If there is no winner in the current round, then all players in THIS round can withdraw 99% of their ether(or chips).
// 4.The contract manager take the management fee (1% of the deposit balance, ether or chips).
// 5.When refunding ether, the player will get equivalent ChipsToken as the management fee they spend.
// 6.When players purchase tickets using ChipsToken, they will receive a 50% discount compared to paying with Ether.
// 7.The number of players using ChipsToken should be less than 50% of the total players in a round.
// NOTE: If there's a winner in a round, she/he will get all the prize pool so other players can't refund their tickets any more. 

contract RefundableLottery is VRFConsumerBaseV2 {
    // 1% management fee
    uint public constant MANAGEMENT_FEE_RATE = 1;

    // ether for each ticket
    uint public constant TICKET_PRICE_IN_ETHER = 0.01 ether;

    // Ticket number range [0, 65535]
    uint public constant TICKET_NUMBER_RANGE = 65535;

    // 1000 chips == 1 eth
    uint public constant CHIPS_PRICE_PER_ETHER = 1000;

    // 50% discount for players using ChipsToken
    uint public constant DISCOUNT_RATE = 50;

    // The price of ChipsToken is 1 ether == 1000 chips, so the original price of a ticket in ChipsToken is 10 chips.
    // But we offer a 50% discount for players using ChipsToken, so the price of a ticket in ChipsToken is 5 chips.
    uint public constant TICKET_PRICE_IN_CHIPS = TICKET_PRICE_IN_ETHER * CHIPS_PRICE_PER_ETHER * (100 - DISCOUNT_RATE)/100;
    
    // In a round, the number of players using ChipsToken should be less than 50% of the total players. 
    uint public constant MAX_PARTICIPATE_RATE_USING_CHIPS = 50;

    // The period of each round by blocks, about 1.5 hours.
    uint public constant ROUND_PERIOD = 1000;

    // The manager of the contract takes the 1% management fee
    address payable public immutable manager;
    
    //The current round number
    uint public roundNumber;

    enum RoundState { NOT_STARTED, PLAYING, ROLLING, COMPLETE}

    struct RoundInfo{
        RoundState state;
        uint startBlockNumber;
        uint chainlinkResult;
        uint jackpotNumber;
        uint requestId;
        uint winnerCount;
    }
    mapping (uint => RoundInfo) public roundInfos;

    //The mapping of the purchase count in each round
    mapping(uint => uint) public etherPurchaseCount;
    mapping(uint => uint) public chipsPurchaseCount;

    //The mapping of the purchase count of each player in each round
    mapping(uint => mapping(address => uint) ) public holderEtherPurchaseCount;
    mapping(uint => mapping(address => uint) ) public holderChipsPurchaseCount;

    //The holders of a ticket.
    //A ticket can be held by more than one player.
    //If the ticket number is chosen as the jackpot number, all the holders of this ticket will share the prize.
    mapping(uint => mapping(uint => address[])) public ticketHolders;

    //The balance of each round.
    //If there is no winner in this round, all players can refund 99% of their ether in this round,
    //and the round balance will be reduced every time a player makes a refund.
    //If there is a winner in this round, the winner(s) get(s) all the ether in this round, 
    //and round_balance will be set to ZERO after draw.
    mapping(uint => uint) public roundEtherBalance;
    mapping(uint => uint) public roundChipsBalance;

    //The mapping of requestId to round number
    mapping(uint => uint) public requestIdToRound;

    //The chips token contract, which is used to mint ChipsToken for the players when refunding.
    IChipsToken public chipsToken;

    event RoundStarted(uint indexed round, uint block_number);
    event BuyTicketEther(address indexed player, uint indexed round, uint ticket_num);
    event BuyTicketChips(address indexed player, uint indexed round, uint ticket_num);
    event LotteryRolling(uint indexed round, uint requestId, address roller, uint startBlockNum, uint blockNum);
    event DrawLottoryEther(uint indexed round, uint jackpotNum, address winner, uint amount);
    event DrawLottoryChips(uint indexed round, uint jackpotNum, address winner, uint amount);
    event RefundEther( uint indexed round, address indexed player, uint refund_balance);
    event RefundChips( uint indexed round, address indexed player, uint refund_balance);
    event RoundEnded(uint indexed round, uint chainlinkResult, uint jackpot_num, uint block_height, uint winner_count);
    
    // Sepolia coordinator. For other networks,
    // see https://docs.chain.link/docs/vrf-contracts/#configurations
    address public vrfCoordinatorAddr = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    VRFCoordinatorV2Interface public COORDINATOR;

    // The gas lane to use, which specifies the maximum gas price to bump to.
    // For a list of available gas lanes on each network,
    // see https://docs.chain.link/docs/vrf-contracts/#configurations
    bytes32 public keyHash = 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;
   
    uint32 public callbackGasLimit = 20000000;

    uint16 public requestConfirmations = 3;

    uint64 public subscriptionId;

    constructor(uint64 _subscriptionId, address _vrf, address _chipsToken) VRFConsumerBaseV2(vrfCoordinatorAddr) {
        vrfCoordinatorAddr = _vrf; //ALERT: this line MUST be removed before launche

        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinatorAddr);
        subscriptionId = _subscriptionId;

        chipsToken = IChipsToken(_chipsToken);
        manager = payable(msg.sender);

        roundNumber = 1;
        roundInfos[roundNumber].state = RoundState.PLAYING;
        roundInfos[roundNumber].startBlockNumber = block.number;
        emit RoundStarted(roundNumber, block.number);
    }

    //Pickup a lucky number between [0, 65535] as your ticket number, 0 and 65535 are both acceptable.
    function buyTicketWithEther(uint _ticket_lucky_num) public payable {
        require(roundInfos[roundNumber].state == RoundState.PLAYING, "The current round is not playing");
        require(roundInfos[roundNumber].startBlockNumber + ROUND_PERIOD > block.number, "The current round is end, please wait for the next round");
        require(msg.value == TICKET_PRICE_IN_ETHER, "The price for a ticket is 0.01 ether");
        require(_ticket_lucky_num >= 0 && _ticket_lucky_num <= TICKET_NUMBER_RANGE, "The ticket number should be between [0,65535]");
        require(msg.sender == tx.origin, "Only EOA(Externally Owned Account) can call this function");

        holderEtherPurchaseCount[roundNumber][msg.sender] += 1;
        ticketHolders[roundNumber][_ticket_lucky_num].push(msg.sender);
        roundEtherBalance[roundNumber] += msg.value;
        
        etherPurchaseCount[roundNumber] += 1;
        emit BuyTicketEther(msg.sender, roundNumber, _ticket_lucky_num);
    }

    function buyTicketWithChips(uint _ticket_lucky_num) public {
        require(roundInfos[roundNumber].state == RoundState.PLAYING, "The current round is not playing");
        require(roundInfos[roundNumber].startBlockNumber + ROUND_PERIOD > block.number, "The current round is end, please wait for the next round");     
        require(_ticket_lucky_num >= 0 && _ticket_lucky_num <= TICKET_NUMBER_RANGE, "The ticket number should be between [0,65535]");
        require(msg.sender == tx.origin, "Only EOA(Externally Owned Account) can call this function");

        chipsPurchaseCount[roundNumber] += 1;
        uint a = chipsPurchaseCount[roundNumber];
        uint b = etherPurchaseCount[roundNumber];
        require(b > 0, "There is no player using Ether in this round, so you can not use ChipsToken");
        require((a*100)/(a+b) <= MAX_PARTICIPATE_RATE_USING_CHIPS, "The number of players using ChipsToken should be less than 50% of the total players");
        
        holderChipsPurchaseCount[roundNumber][msg.sender] += 1;
        ticketHolders[roundNumber][_ticket_lucky_num].push(msg.sender);

        //The directTransferFrom will revert if the player does not have enough ChipsToken.
        chipsToken.directTransferFrom(msg.sender, address(this), TICKET_PRICE_IN_CHIPS);
        roundChipsBalance[roundNumber] += TICKET_PRICE_IN_CHIPS;

        emit BuyTicketChips(msg.sender, roundNumber, _ticket_lucky_num);
    }

    // ALERT: this block MUST be removed before launche
    function invokeFulfillRandomWords(uint _requestId, uint256[] memory _randomWords) public{
        fulfillRandomWords(_requestId, _randomWords);
    }
        
    //Any player can call this function to trigger the draw operation.
    //This function will request a random number from Chainlink VRF.
    //And the Chainlink VRF will callback the fulfillRandomWords function in several block.
    function drawLottery() public returns(uint){
        require(roundInfos[roundNumber].state == RoundState.PLAYING, "The current round is NOT in playing");
        require(roundInfos[roundNumber].startBlockNumber + ROUND_PERIOD <= block.number, "The current round is not end yet");
        
        //The draw operation can only be called one time for each round.
        roundInfos[roundNumber].state = RoundState.ROLLING;

        uint requestId = COORDINATOR.requestRandomWords(
            keyHash,
            subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            1
        );
        roundInfos[roundNumber].requestId = requestId;
        requestIdToRound[requestId] = roundNumber;
        emit LotteryRolling(roundNumber, requestId, msg.sender, roundInfos[roundNumber].startBlockNumber, block.number);
        return requestId;
    }

    //The Chainlink VRF will callback this function to fulfill the random number request.
    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
        require(requestIdToRound[_requestId] == roundNumber, "The requestId is not for the current round");
        require(roundInfos[roundNumber].state == RoundState.ROLLING, "The current round state is not ROLLING");
        
        //Generate a random number between [0, 65535] using the random number generated by Chainlink VRF.
        uint256 jackpotNum = _randomWords[0] % (TICKET_NUMBER_RANGE + 1); //0 <= jackpotNum <= 65535

        roundInfos[roundNumber].chainlinkResult = _randomWords[0];
        roundInfos[roundNumber].jackpotNumber = jackpotNum;
        roundInfos[roundNumber].winnerCount = drawLotteryInternal(jackpotNum);
        roundInfos[roundNumber].state = RoundState.COMPLETE;
        emit RoundEnded(roundNumber, _randomWords[0], jackpotNum, block.number, roundInfos[roundNumber].winnerCount);

        //The next round will not start until the current round is draw.
        roundNumber += 1;
        roundInfos[roundNumber].state = RoundState.PLAYING;
        roundInfos[roundNumber].startBlockNumber = block.number;
        emit RoundStarted(roundNumber, block.number);
    }

    function drawLotteryInternal(uint _jackpotNum) internal returns(uint) {
        //If there is no player in this round, nothing to do and start the next round.
        if(roundEtherBalance[roundNumber] == 0){
            return 0;
        }

        //The manager of the contract take the management fee (1% of the deposit balance).
        uint managementFeeEther = roundEtherBalance[roundNumber] * MANAGEMENT_FEE_RATE / 100;
        roundEtherBalance[roundNumber] -= managementFeeEther;
        manager.transfer(managementFeeEther);

        uint managementFeeChips = roundChipsBalance[roundNumber] * MANAGEMENT_FEE_RATE / 100;
        roundChipsBalance[roundNumber] -= managementFeeChips;
        chipsToken.transfer(manager, managementFeeChips);

        //The winners could be more than ONE player and they will share the ether/chips in the current round.
        uint winnerCount = ticketHolders[roundNumber][_jackpotNum].length;
        if(winnerCount > 0){
            uint winnerEther = roundEtherBalance[roundNumber] / ticketHolders[roundNumber][_jackpotNum].length;
            uint winnerChips = roundChipsBalance[roundNumber] / ticketHolders[roundNumber][_jackpotNum].length;
            
            roundEtherBalance[roundNumber] = 0;
            roundChipsBalance[roundNumber] = 0;

            for(uint i = 0; i < ticketHolders[roundNumber][_jackpotNum].length; i++){
                payable(ticketHolders[roundNumber][_jackpotNum][i]).transfer(winnerEther);
                emit DrawLottoryEther(roundNumber, _jackpotNum, ticketHolders[roundNumber][_jackpotNum][i], winnerEther);
                
                if(winnerChips > 0){
                    require(chipsToken.transfer(ticketHolders[roundNumber][_jackpotNum][i], winnerChips), "The transfer of ChipsToken failed");
                    emit DrawLottoryChips(roundNumber, _jackpotNum, ticketHolders[roundNumber][_jackpotNum][i], winnerChips);
                }
            }
        }
        return ticketHolders[roundNumber][_jackpotNum].length;
    }

    function refundEther(uint _previousRoundNumber) public  {
        require(roundInfos[_previousRoundNumber].state == RoundState.COMPLETE, "You can not refund a round which is not completed");
        require(roundInfos[_previousRoundNumber].winnerCount == 0, "The prize pool of this round has been taken by the winner(s)");
        
        //A player can refund all the tickets he/she holds in the previous round as long as there is no winner in that round.
        uint ticketsCount = holderEtherPurchaseCount[_previousRoundNumber][msg.sender];
        require(ticketsCount > 0, "You did not hold any ticket purchased by ether in this round");
        delete holderEtherPurchaseCount[_previousRoundNumber][msg.sender];

        uint refundAmount = ticketsCount * TICKET_PRICE_IN_ETHER * (100 - MANAGEMENT_FEE_RATE) / 100;
        require(roundEtherBalance[_previousRoundNumber] >= refundAmount, "The balance of this round is not enough for refund");
        require(address(this).balance >= refundAmount, "The contract balance is not enough for refund");
        roundEtherBalance[_previousRoundNumber] -= refundAmount;
        payable(msg.sender).transfer(refundAmount);
        
        emit RefundEther(_previousRoundNumber, msg.sender, refundAmount);

        //As player paid 1% management fee when playing the game, the player will get equivalent ChipsToken when refunding.
        //For example, if a player paid 0.01 ether for a ticket, the management fee is 0.01 * 1% = 0.0001 ether.
        //As the price of ticket in one ether is 1000 chips, the player will get 0.0001 * 1000 = 0.1 chips when refunding.
        chipsToken.mint(msg.sender, ticketsCount * TICKET_PRICE_IN_ETHER * MANAGEMENT_FEE_RATE * CHIPS_PRICE_PER_ETHER/100 );
    }

    function refundChips(uint _previousRoundNumber) public {
        require(roundInfos[_previousRoundNumber].state == RoundState.COMPLETE, "You can not refund a round which is not completed");
        require(roundInfos[_previousRoundNumber].winnerCount == 0, "The prize pool of this round has been taken by the winner(s)");
        
        //A player can refund all the tickets he/she holds in the previous round as long as there is no winner in that round.
        uint tickets_count = holderChipsPurchaseCount[_previousRoundNumber][msg.sender];
        require(tickets_count > 0, "You did not hold any ticket purchased by Chips  in this round");
        delete holderChipsPurchaseCount[_previousRoundNumber][msg.sender];

        uint refund_balance = tickets_count * TICKET_PRICE_IN_CHIPS * (100 - MANAGEMENT_FEE_RATE) / 100;
        require(roundChipsBalance[_previousRoundNumber] >= refund_balance, "The balance of this round is not enough for refund");
        require(chipsToken.balanceOf(address(this)) >= refund_balance, "The contract balance is not enough for refund");
        roundChipsBalance[_previousRoundNumber] -= refund_balance;
        require(chipsToken.transfer(msg.sender, refund_balance), "The transfer of ChipsToken failed");
        
        emit RefundChips(_previousRoundNumber, msg.sender, refund_balance);
        //The player will NOT get extra ChipsToken when refunding chips token.
    }
}
